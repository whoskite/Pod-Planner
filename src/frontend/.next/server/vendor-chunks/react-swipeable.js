"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-swipeable";
exports.ids = ["vendor-chunks/react-swipeable"];
exports.modules = {

/***/ "(ssr)/../../node_modules/react-swipeable/es/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/react-swipeable/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOWN: () => (/* binding */ DOWN),\n/* harmony export */   LEFT: () => (/* binding */ LEFT),\n/* harmony export */   RIGHT: () => (/* binding */ RIGHT),\n/* harmony export */   UP: () => (/* binding */ UP),\n/* harmony export */   useSwipeable: () => (/* binding */ useSwipeable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst LEFT = \"Left\";\nconst RIGHT = \"Right\";\nconst UP = \"Up\";\nconst DOWN = \"Down\";\n\n/* global document */\nconst defaultProps = {\n    delta: 10,\n    preventScrollOnSwipe: false,\n    rotationAngle: 0,\n    trackMouse: false,\n    trackTouch: true,\n    swipeDuration: Infinity,\n    touchEventOptions: { passive: true },\n};\nconst initialState = {\n    first: true,\n    initial: [0, 0],\n    start: 0,\n    swiping: false,\n    xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\nfunction getDirection(absX, absY, deltaX, deltaY) {\n    if (absX > absY) {\n        if (deltaX > 0) {\n            return RIGHT;\n        }\n        return LEFT;\n    }\n    else if (deltaY > 0) {\n        return DOWN;\n    }\n    return UP;\n}\nfunction rotateXYByAngle(pos, angle) {\n    if (angle === 0)\n        return pos;\n    const angleInRadians = (Math.PI / 180) * angle;\n    const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n    const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n    return [x, y];\n}\nfunction getHandlers(set, handlerProps) {\n    const onStart = (event) => {\n        const isTouch = \"touches\" in event;\n        // if more than a single touch don't track, for now...\n        if (isTouch && event.touches.length > 1)\n            return;\n        set((state, props) => {\n            // setup mouse listeners on document to track swipe since swipe can leave container\n            if (props.trackMouse && !isTouch) {\n                document.addEventListener(mouseMove, onMove);\n                document.addEventListener(mouseUp, onUp);\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            props.onTouchStartOrOnMouseDown &&\n                props.onTouchStartOrOnMouseDown({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { initial: xy.slice(), xy, start: event.timeStamp || 0 });\n        });\n    };\n    const onMove = (event) => {\n        set((state, props) => {\n            const isTouch = \"touches\" in event;\n            // Discount a swipe if additional touches are present after\n            // a swipe has started.\n            if (isTouch && event.touches.length > 1) {\n                return state;\n            }\n            // if swipe has exceeded duration stop tracking\n            if (event.timeStamp - state.start > props.swipeDuration) {\n                return state.swiping ? Object.assign(Object.assign({}, state), { swiping: false }) : state;\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            const deltaX = x - state.xy[0];\n            const deltaY = y - state.xy[1];\n            const absX = Math.abs(deltaX);\n            const absY = Math.abs(deltaY);\n            const time = (event.timeStamp || 0) - state.start;\n            const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n            const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n            const dir = getDirection(absX, absY, deltaX, deltaY);\n            // if swipe is under delta and we have not started to track a swipe: skip update\n            const delta = typeof props.delta === \"number\"\n                ? props.delta\n                : props.delta[dir.toLowerCase()] ||\n                    defaultProps.delta;\n            if (absX < delta && absY < delta && !state.swiping)\n                return state;\n            const eventData = {\n                absX,\n                absY,\n                deltaX,\n                deltaY,\n                dir,\n                event,\n                first: state.first,\n                initial: state.initial,\n                velocity,\n                vxvy,\n            };\n            // call onSwipeStart if present and is first swipe event\n            eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n            // call onSwiping if present\n            props.onSwiping && props.onSwiping(eventData);\n            // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n            // so we can call preventDefault if needed\n            let cancelablePageSwipe = false;\n            if (props.onSwiping ||\n                props.onSwiped ||\n                props[`onSwiped${dir}`]) {\n                cancelablePageSwipe = true;\n            }\n            if (cancelablePageSwipe &&\n                props.preventScrollOnSwipe &&\n                props.trackTouch &&\n                event.cancelable) {\n                event.preventDefault();\n            }\n            return Object.assign(Object.assign({}, state), { \n                // first is now always false\n                first: false, eventData, swiping: true });\n        });\n    };\n    const onEnd = (event) => {\n        set((state, props) => {\n            let eventData;\n            if (state.swiping && state.eventData) {\n                // if swipe is less than duration fire swiped callbacks\n                if (event.timeStamp - state.start < props.swipeDuration) {\n                    eventData = Object.assign(Object.assign({}, state.eventData), { event });\n                    props.onSwiped && props.onSwiped(eventData);\n                    const onSwipedDir = props[`onSwiped${eventData.dir}`];\n                    onSwipedDir && onSwipedDir(eventData);\n                }\n            }\n            else {\n                props.onTap && props.onTap({ event });\n            }\n            props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { eventData });\n        });\n    };\n    const cleanUpMouse = () => {\n        // safe to just call removeEventListener\n        document.removeEventListener(mouseMove, onMove);\n        document.removeEventListener(mouseUp, onUp);\n    };\n    const onUp = (e) => {\n        cleanUpMouse();\n        onEnd(e);\n    };\n    /**\n     * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n     * - true => { passive: false }\n     * - false => { passive: true } // Default\n     *\n     * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n     *\n     * props.touchEventOptions can also be set for all touch event listeners,\n     * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n     * supersede and force passive to false.\n     *\n     */\n    const attachTouch = (el, props) => {\n        let cleanup = () => { };\n        if (el && el.addEventListener) {\n            const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);\n            // attach touch event listeners and handlers\n            const tls = [\n                [touchStart, onStart, baseOptions],\n                // preventScrollOnSwipe option supersedes touchEventOptions.passive\n                [\n                    touchMove,\n                    onMove,\n                    Object.assign(Object.assign({}, baseOptions), (props.preventScrollOnSwipe ? { passive: false } : {})),\n                ],\n                [touchEnd, onEnd, baseOptions],\n            ];\n            tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n            // return properly scoped cleanup method for removing listeners, options not required\n            cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n        }\n        return cleanup;\n    };\n    const onRef = (el) => {\n        // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n        // ignore null here\n        if (el === null)\n            return;\n        set((state, props) => {\n            // if the same DOM el as previous just return state\n            if (state.el === el)\n                return state;\n            const addState = {};\n            // if new DOM el clean up old DOM and reset cleanUpTouch\n            if (state.el && state.el !== el && state.cleanUpTouch) {\n                state.cleanUpTouch();\n                addState.cleanUpTouch = void 0;\n            }\n            // only attach if we want to track touch\n            if (props.trackTouch && el) {\n                addState.cleanUpTouch = attachTouch(el, props);\n            }\n            // store event attached DOM el for comparison, clean up, and re-attachment\n            return Object.assign(Object.assign(Object.assign({}, state), { el }), addState);\n        });\n    };\n    // set ref callback to attach touch event listeners\n    const output = {\n        ref: onRef,\n    };\n    // if track mouse attach mouse down listener\n    if (handlerProps.trackMouse) {\n        output.onMouseDown = onStart;\n    }\n    return [output, attachTouch];\n}\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n    // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n    if (!props.trackTouch || !state.el) {\n        if (state.cleanUpTouch) {\n            state.cleanUpTouch();\n        }\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: undefined });\n    }\n    // trackTouch is on, so if there are no handlers attached, attach them and exit\n    if (!state.cleanUpTouch) {\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n    // remove and reattach handlers (this is required to update the passive option when attaching\n    // the handlers)\n    if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n        props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n        state.cleanUpTouch();\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    return state;\n}\nfunction useSwipeable(options) {\n    const { trackMouse } = options;\n    const transientState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Object.assign({}, initialState));\n    const transientProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Object.assign({}, defaultProps));\n    // track previous rendered props\n    const previousProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Object.assign({}, transientProps.current));\n    previousProps.current = Object.assign({}, transientProps.current);\n    // update current render props & defaults\n    transientProps.current = Object.assign(Object.assign({}, defaultProps), options);\n    // Force defaults for config properties\n    let defaultKey;\n    for (defaultKey in defaultProps) {\n        if (transientProps.current[defaultKey] === void 0) {\n            transientProps.current[defaultKey] = defaultProps[defaultKey];\n        }\n    }\n    const [handlers, attachTouch] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => getHandlers((stateSetter) => (transientState.current = stateSetter(transientState.current, transientProps.current)), { trackMouse }), [trackMouse]);\n    transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n    return handlers;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXN3aXBlYWJsZS9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQsK0RBQStELDJCQUEyQixzREFBc0Q7QUFDaEosU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsWUFBWSxnQkFBZ0I7QUFDakc7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLHdEQUF3RDtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsc0JBQXNCLE9BQU87QUFDM0Y7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0EseUVBQXlFLE9BQU87QUFDaEYsK0RBQStELDJCQUEyQixXQUFXO0FBQ3JHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdEQUFnRCxpQkFBaUIsSUFBSTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVksSUFBSTtBQUMvRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZLHlCQUF5QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWSw0Q0FBNEM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWSw0Q0FBNEM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsMkJBQTJCLHlDQUFZLGlCQUFpQjtBQUN4RCwyQkFBMkIseUNBQVksaUJBQWlCO0FBQ3hEO0FBQ0EsMEJBQTBCLHlDQUFZLGlCQUFpQjtBQUN2RCw0Q0FBNEM7QUFDNUM7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQWEsOEhBQThILFlBQVk7QUFDM0w7QUFDQTtBQUNBOztBQUUrQztBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3dpcGVhYmxlL2VzL2luZGV4LmpzP2UzOWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBMRUZUID0gXCJMZWZ0XCI7XG5jb25zdCBSSUdIVCA9IFwiUmlnaHRcIjtcbmNvbnN0IFVQID0gXCJVcFwiO1xuY29uc3QgRE9XTiA9IFwiRG93blwiO1xuXG4vKiBnbG9iYWwgZG9jdW1lbnQgKi9cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkZWx0YTogMTAsXG4gICAgcHJldmVudFNjcm9sbE9uU3dpcGU6IGZhbHNlLFxuICAgIHJvdGF0aW9uQW5nbGU6IDAsXG4gICAgdHJhY2tNb3VzZTogZmFsc2UsXG4gICAgdHJhY2tUb3VjaDogdHJ1ZSxcbiAgICBzd2lwZUR1cmF0aW9uOiBJbmZpbml0eSxcbiAgICB0b3VjaEV2ZW50T3B0aW9uczogeyBwYXNzaXZlOiB0cnVlIH0sXG59O1xuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIGZpcnN0OiB0cnVlLFxuICAgIGluaXRpYWw6IFswLCAwXSxcbiAgICBzdGFydDogMCxcbiAgICBzd2lwaW5nOiBmYWxzZSxcbiAgICB4eTogWzAsIDBdLFxufTtcbmNvbnN0IG1vdXNlTW92ZSA9IFwibW91c2Vtb3ZlXCI7XG5jb25zdCBtb3VzZVVwID0gXCJtb3VzZXVwXCI7XG5jb25zdCB0b3VjaEVuZCA9IFwidG91Y2hlbmRcIjtcbmNvbnN0IHRvdWNoTW92ZSA9IFwidG91Y2htb3ZlXCI7XG5jb25zdCB0b3VjaFN0YXJ0ID0gXCJ0b3VjaHN0YXJ0XCI7XG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oYWJzWCwgYWJzWSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBpZiAoYWJzWCA+IGFic1kpIHtcbiAgICAgICAgaWYgKGRlbHRhWCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBSSUdIVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTEVGVDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgICByZXR1cm4gRE9XTjtcbiAgICB9XG4gICAgcmV0dXJuIFVQO1xufVxuZnVuY3Rpb24gcm90YXRlWFlCeUFuZ2xlKHBvcywgYW5nbGUpIHtcbiAgICBpZiAoYW5nbGUgPT09IDApXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgY29uc3QgYW5nbGVJblJhZGlhbnMgPSAoTWF0aC5QSSAvIDE4MCkgKiBhbmdsZTtcbiAgICBjb25zdCB4ID0gcG9zWzBdICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpICsgcG9zWzFdICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgIGNvbnN0IHkgPSBwb3NbMV0gKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucykgLSBwb3NbMF0gKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZXJzKHNldCwgaGFuZGxlclByb3BzKSB7XG4gICAgY29uc3Qgb25TdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBpc1RvdWNoID0gXCJ0b3VjaGVzXCIgaW4gZXZlbnQ7XG4gICAgICAgIC8vIGlmIG1vcmUgdGhhbiBhIHNpbmdsZSB0b3VjaCBkb24ndCB0cmFjaywgZm9yIG5vdy4uLlxuICAgICAgICBpZiAoaXNUb3VjaCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldCgoc3RhdGUsIHByb3BzKSA9PiB7XG4gICAgICAgICAgICAvLyBzZXR1cCBtb3VzZSBsaXN0ZW5lcnMgb24gZG9jdW1lbnQgdG8gdHJhY2sgc3dpcGUgc2luY2Ugc3dpcGUgY2FuIGxlYXZlIGNvbnRhaW5lclxuICAgICAgICAgICAgaWYgKHByb3BzLnRyYWNrTW91c2UgJiYgIWlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG1vdXNlTW92ZSwgb25Nb3ZlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG1vdXNlVXAsIG9uVXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBpc1RvdWNoID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuICAgICAgICAgICAgY29uc3QgeHkgPSByb3RhdGVYWUJ5QW5nbGUoW2NsaWVudFgsIGNsaWVudFldLCBwcm9wcy5yb3RhdGlvbkFuZ2xlKTtcbiAgICAgICAgICAgIHByb3BzLm9uVG91Y2hTdGFydE9yT25Nb3VzZURvd24gJiZcbiAgICAgICAgICAgICAgICBwcm9wcy5vblRvdWNoU3RhcnRPck9uTW91c2VEb3duKHsgZXZlbnQgfSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgaW5pdGlhbFN0YXRlKSwgeyBpbml0aWFsOiB4eS5zbGljZSgpLCB4eSwgc3RhcnQ6IGV2ZW50LnRpbWVTdGFtcCB8fCAwIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICBzZXQoKHN0YXRlLCBwcm9wcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNUb3VjaCA9IFwidG91Y2hlc1wiIGluIGV2ZW50O1xuICAgICAgICAgICAgLy8gRGlzY291bnQgYSBzd2lwZSBpZiBhZGRpdGlvbmFsIHRvdWNoZXMgYXJlIHByZXNlbnQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGEgc3dpcGUgaGFzIHN0YXJ0ZWQuXG4gICAgICAgICAgICBpZiAoaXNUb3VjaCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBzd2lwZSBoYXMgZXhjZWVkZWQgZHVyYXRpb24gc3RvcCB0cmFja2luZ1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRpbWVTdGFtcCAtIHN0YXRlLnN0YXJ0ID4gcHJvcHMuc3dpcGVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zd2lwaW5nID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgc3dpcGluZzogZmFsc2UgfSkgOiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gaXNUb3VjaCA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IHJvdGF0ZVhZQnlBbmdsZShbY2xpZW50WCwgY2xpZW50WV0sIHByb3BzLnJvdGF0aW9uQW5nbGUpO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFYID0geCAtIHN0YXRlLnh5WzBdO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFZID0geSAtIHN0YXRlLnh5WzFdO1xuICAgICAgICAgICAgY29uc3QgYWJzWCA9IE1hdGguYWJzKGRlbHRhWCk7XG4gICAgICAgICAgICBjb25zdCBhYnNZID0gTWF0aC5hYnMoZGVsdGFZKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSAoZXZlbnQudGltZVN0YW1wIHx8IDApIC0gc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IE1hdGguc3FydChhYnNYICogYWJzWCArIGFic1kgKiBhYnNZKSAvICh0aW1lIHx8IDEpO1xuICAgICAgICAgICAgY29uc3Qgdnh2eSA9IFtkZWx0YVggLyAodGltZSB8fCAxKSwgZGVsdGFZIC8gKHRpbWUgfHwgMSldO1xuICAgICAgICAgICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKGFic1gsIGFic1ksIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgICAgIC8vIGlmIHN3aXBlIGlzIHVuZGVyIGRlbHRhIGFuZCB3ZSBoYXZlIG5vdCBzdGFydGVkIHRvIHRyYWNrIGEgc3dpcGU6IHNraXAgdXBkYXRlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IHR5cGVvZiBwcm9wcy5kZWx0YSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgID8gcHJvcHMuZGVsdGFcbiAgICAgICAgICAgICAgICA6IHByb3BzLmRlbHRhW2Rpci50b0xvd2VyQ2FzZSgpXSB8fFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvcHMuZGVsdGE7XG4gICAgICAgICAgICBpZiAoYWJzWCA8IGRlbHRhICYmIGFic1kgPCBkZWx0YSAmJiAhc3RhdGUuc3dpcGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBldmVudERhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWJzWCxcbiAgICAgICAgICAgICAgICBhYnNZLFxuICAgICAgICAgICAgICAgIGRlbHRhWCxcbiAgICAgICAgICAgICAgICBkZWx0YVksXG4gICAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGZpcnN0OiBzdGF0ZS5maXJzdCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiBzdGF0ZS5pbml0aWFsLFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5LFxuICAgICAgICAgICAgICAgIHZ4dnksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY2FsbCBvblN3aXBlU3RhcnQgaWYgcHJlc2VudCBhbmQgaXMgZmlyc3Qgc3dpcGUgZXZlbnRcbiAgICAgICAgICAgIGV2ZW50RGF0YS5maXJzdCAmJiBwcm9wcy5vblN3aXBlU3RhcnQgJiYgcHJvcHMub25Td2lwZVN0YXJ0KGV2ZW50RGF0YSk7XG4gICAgICAgICAgICAvLyBjYWxsIG9uU3dpcGluZyBpZiBwcmVzZW50XG4gICAgICAgICAgICBwcm9wcy5vblN3aXBpbmcgJiYgcHJvcHMub25Td2lwaW5nKGV2ZW50RGF0YSk7XG4gICAgICAgICAgICAvLyB0cmFjayBpZiBhIHN3aXBlIGlzIGNhbmNlbGFibGUgKGhhbmRsZXIgZm9yIHN3aXBpbmcgb3Igc3dpcGVkKGRpcikgZXhpc3RzKVxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgaWYgbmVlZGVkXG4gICAgICAgICAgICBsZXQgY2FuY2VsYWJsZVBhZ2VTd2lwZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHByb3BzLm9uU3dpcGluZyB8fFxuICAgICAgICAgICAgICAgIHByb3BzLm9uU3dpcGVkIHx8XG4gICAgICAgICAgICAgICAgcHJvcHNbYG9uU3dpcGVkJHtkaXJ9YF0pIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlUGFnZVN3aXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxhYmxlUGFnZVN3aXBlICYmXG4gICAgICAgICAgICAgICAgcHJvcHMucHJldmVudFNjcm9sbE9uU3dpcGUgJiZcbiAgICAgICAgICAgICAgICBwcm9wcy50cmFja1RvdWNoICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgaXMgbm93IGFsd2F5cyBmYWxzZVxuICAgICAgICAgICAgICAgIGZpcnN0OiBmYWxzZSwgZXZlbnREYXRhLCBzd2lwaW5nOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHNldCgoc3RhdGUsIHByb3BzKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXZlbnREYXRhO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN3aXBpbmcgJiYgc3RhdGUuZXZlbnREYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgc3dpcGUgaXMgbGVzcyB0aGFuIGR1cmF0aW9uIGZpcmUgc3dpcGVkIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50aW1lU3RhbXAgLSBzdGF0ZS5zdGFydCA8IHByb3BzLnN3aXBlRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5ldmVudERhdGEpLCB7IGV2ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vblN3aXBlZCAmJiBwcm9wcy5vblN3aXBlZChldmVudERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvblN3aXBlZERpciA9IHByb3BzW2BvblN3aXBlZCR7ZXZlbnREYXRhLmRpcn1gXTtcbiAgICAgICAgICAgICAgICAgICAgb25Td2lwZWREaXIgJiYgb25Td2lwZWREaXIoZXZlbnREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5vblRhcCAmJiBwcm9wcy5vblRhcCh7IGV2ZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMub25Ub3VjaEVuZE9yT25Nb3VzZVVwICYmIHByb3BzLm9uVG91Y2hFbmRPck9uTW91c2VVcCh7IGV2ZW50IH0pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIGluaXRpYWxTdGF0ZSksIHsgZXZlbnREYXRhIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNsZWFuVXBNb3VzZSA9ICgpID0+IHtcbiAgICAgICAgLy8gc2FmZSB0byBqdXN0IGNhbGwgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlTW92ZSwgb25Nb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVVwLCBvblVwKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uVXAgPSAoZSkgPT4ge1xuICAgICAgICBjbGVhblVwTW91c2UoKTtcbiAgICAgICAgb25FbmQoZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgcGFzc2l2ZSBvbiB0b3VjaE1vdmUgZGVwZW5kcyBvbiBgcHJldmVudFNjcm9sbE9uU3dpcGVgOlxuICAgICAqIC0gdHJ1ZSA9PiB7IHBhc3NpdmU6IGZhbHNlIH1cbiAgICAgKiAtIGZhbHNlID0+IHsgcGFzc2l2ZTogdHJ1ZSB9IC8vIERlZmF1bHRcbiAgICAgKlxuICAgICAqIE5PVEU6IFdoZW4gcHJldmVudFNjcm9sbE9uU3dpcGUgaXMgdHJ1ZSwgd2UgYXR0ZW1wdCB0byBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgc2Nyb2xsLlxuICAgICAqXG4gICAgICogcHJvcHMudG91Y2hFdmVudE9wdGlvbnMgY2FuIGFsc28gYmUgc2V0IGZvciBhbGwgdG91Y2ggZXZlbnQgbGlzdGVuZXJzLFxuICAgICAqIGJ1dCBmb3IgYHRvdWNobW92ZWAgc3BlY2lmaWNhbGx5IHdoZW4gYHByZXZlbnRTY3JvbGxPblN3aXBlYCBpdCB3aWxsXG4gICAgICogc3VwZXJzZWRlIGFuZCBmb3JjZSBwYXNzaXZlIHRvIGZhbHNlLlxuICAgICAqXG4gICAgICovXG4gICAgY29uc3QgYXR0YWNoVG91Y2ggPSAoZWwsIHByb3BzKSA9PiB7XG4gICAgICAgIGxldCBjbGVhbnVwID0gKCkgPT4geyB9O1xuICAgICAgICBpZiAoZWwgJiYgZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgYmFzZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcy50b3VjaEV2ZW50T3B0aW9ucyksIHByb3BzLnRvdWNoRXZlbnRPcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGF0dGFjaCB0b3VjaCBldmVudCBsaXN0ZW5lcnMgYW5kIGhhbmRsZXJzXG4gICAgICAgICAgICBjb25zdCB0bHMgPSBbXG4gICAgICAgICAgICAgICAgW3RvdWNoU3RhcnQsIG9uU3RhcnQsIGJhc2VPcHRpb25zXSxcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50U2Nyb2xsT25Td2lwZSBvcHRpb24gc3VwZXJzZWRlcyB0b3VjaEV2ZW50T3B0aW9ucy5wYXNzaXZlXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICB0b3VjaE1vdmUsXG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlT3B0aW9ucyksIChwcm9wcy5wcmV2ZW50U2Nyb2xsT25Td2lwZSA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IHt9KSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBbdG91Y2hFbmQsIG9uRW5kLCBiYXNlT3B0aW9uc10sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGxzLmZvckVhY2goKFtlLCBoLCBvXSkgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihlLCBoLCBvKSk7XG4gICAgICAgICAgICAvLyByZXR1cm4gcHJvcGVybHkgc2NvcGVkIGNsZWFudXAgbWV0aG9kIGZvciByZW1vdmluZyBsaXN0ZW5lcnMsIG9wdGlvbnMgbm90IHJlcXVpcmVkXG4gICAgICAgICAgICBjbGVhbnVwID0gKCkgPT4gdGxzLmZvckVhY2goKFtlLCBoXSkgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgfTtcbiAgICBjb25zdCBvblJlZiA9IChlbCkgPT4ge1xuICAgICAgICAvLyBcImlubGluZVwiIHJlZiBmdW5jdGlvbnMgYXJlIGNhbGxlZCB0d2ljZSBvbiByZW5kZXIsIG9uY2Ugd2l0aCBudWxsIHRoZW4gYWdhaW4gd2l0aCBET00gZWxlbWVudFxuICAgICAgICAvLyBpZ25vcmUgbnVsbCBoZXJlXG4gICAgICAgIGlmIChlbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0KChzdGF0ZSwgcHJvcHMpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzYW1lIERPTSBlbCBhcyBwcmV2aW91cyBqdXN0IHJldHVybiBzdGF0ZVxuICAgICAgICAgICAgaWYgKHN0YXRlLmVsID09PSBlbClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBhZGRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgLy8gaWYgbmV3IERPTSBlbCBjbGVhbiB1cCBvbGQgRE9NIGFuZCByZXNldCBjbGVhblVwVG91Y2hcbiAgICAgICAgICAgIGlmIChzdGF0ZS5lbCAmJiBzdGF0ZS5lbCAhPT0gZWwgJiYgc3RhdGUuY2xlYW5VcFRvdWNoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xlYW5VcFRvdWNoKCk7XG4gICAgICAgICAgICAgICAgYWRkU3RhdGUuY2xlYW5VcFRvdWNoID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSBhdHRhY2ggaWYgd2Ugd2FudCB0byB0cmFjayB0b3VjaFxuICAgICAgICAgICAgaWYgKHByb3BzLnRyYWNrVG91Y2ggJiYgZWwpIHtcbiAgICAgICAgICAgICAgICBhZGRTdGF0ZS5jbGVhblVwVG91Y2ggPSBhdHRhY2hUb3VjaChlbCwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RvcmUgZXZlbnQgYXR0YWNoZWQgRE9NIGVsIGZvciBjb21wYXJpc29uLCBjbGVhbiB1cCwgYW5kIHJlLWF0dGFjaG1lbnRcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IGVsIH0pLCBhZGRTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gc2V0IHJlZiBjYWxsYmFjayB0byBhdHRhY2ggdG91Y2ggZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICByZWY6IG9uUmVmLFxuICAgIH07XG4gICAgLy8gaWYgdHJhY2sgbW91c2UgYXR0YWNoIG1vdXNlIGRvd24gbGlzdGVuZXJcbiAgICBpZiAoaGFuZGxlclByb3BzLnRyYWNrTW91c2UpIHtcbiAgICAgICAgb3V0cHV0Lm9uTW91c2VEb3duID0gb25TdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIFtvdXRwdXQsIGF0dGFjaFRvdWNoXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zaWVudFN0YXRlKHN0YXRlLCBwcm9wcywgcHJldmlvdXNQcm9wcywgYXR0YWNoVG91Y2gpIHtcbiAgICAvLyBpZiB0cmFja1RvdWNoIGlzIG9mZiBvciB0aGVyZSBpcyBubyBlbCwgdGhlbiByZW1vdmUgaGFuZGxlcnMgaWYgbmVjZXNzYXJ5IGFuZCBleGl0XG4gICAgaWYgKCFwcm9wcy50cmFja1RvdWNoIHx8ICFzdGF0ZS5lbCkge1xuICAgICAgICBpZiAoc3RhdGUuY2xlYW5VcFRvdWNoKSB7XG4gICAgICAgICAgICBzdGF0ZS5jbGVhblVwVG91Y2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgY2xlYW5VcFRvdWNoOiB1bmRlZmluZWQgfSk7XG4gICAgfVxuICAgIC8vIHRyYWNrVG91Y2ggaXMgb24sIHNvIGlmIHRoZXJlIGFyZSBubyBoYW5kbGVycyBhdHRhY2hlZCwgYXR0YWNoIHRoZW0gYW5kIGV4aXRcbiAgICBpZiAoIXN0YXRlLmNsZWFuVXBUb3VjaCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgY2xlYW5VcFRvdWNoOiBhdHRhY2hUb3VjaChzdGF0ZS5lbCwgcHJvcHMpIH0pO1xuICAgIH1cbiAgICAvLyB0cmFja1RvdWNoIGlzIG9uIGFuZCBoYW5kbGVycyBhcmUgYWxyZWFkeSBhdHRhY2hlZCwgc28gaWYgcHJldmVudFNjcm9sbE9uU3dpcGUgY2hhbmdlcyB2YWx1ZSxcbiAgICAvLyByZW1vdmUgYW5kIHJlYXR0YWNoIGhhbmRsZXJzICh0aGlzIGlzIHJlcXVpcmVkIHRvIHVwZGF0ZSB0aGUgcGFzc2l2ZSBvcHRpb24gd2hlbiBhdHRhY2hpbmdcbiAgICAvLyB0aGUgaGFuZGxlcnMpXG4gICAgaWYgKHByb3BzLnByZXZlbnRTY3JvbGxPblN3aXBlICE9PSBwcmV2aW91c1Byb3BzLnByZXZlbnRTY3JvbGxPblN3aXBlIHx8XG4gICAgICAgIHByb3BzLnRvdWNoRXZlbnRPcHRpb25zLnBhc3NpdmUgIT09IHByZXZpb3VzUHJvcHMudG91Y2hFdmVudE9wdGlvbnMucGFzc2l2ZSkge1xuICAgICAgICBzdGF0ZS5jbGVhblVwVG91Y2goKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IGNsZWFuVXBUb3VjaDogYXR0YWNoVG91Y2goc3RhdGUuZWwsIHByb3BzKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlU3dpcGVhYmxlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYWNrTW91c2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhbnNpZW50U3RhdGUgPSBSZWFjdC51c2VSZWYoT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKSk7XG4gICAgY29uc3QgdHJhbnNpZW50UHJvcHMgPSBSZWFjdC51c2VSZWYoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzKSk7XG4gICAgLy8gdHJhY2sgcHJldmlvdXMgcmVuZGVyZWQgcHJvcHNcbiAgICBjb25zdCBwcmV2aW91c1Byb3BzID0gUmVhY3QudXNlUmVmKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zaWVudFByb3BzLmN1cnJlbnQpKTtcbiAgICBwcmV2aW91c1Byb3BzLmN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LCB0cmFuc2llbnRQcm9wcy5jdXJyZW50KTtcbiAgICAvLyB1cGRhdGUgY3VycmVudCByZW5kZXIgcHJvcHMgJiBkZWZhdWx0c1xuICAgIHRyYW5zaWVudFByb3BzLmN1cnJlbnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcyksIG9wdGlvbnMpO1xuICAgIC8vIEZvcmNlIGRlZmF1bHRzIGZvciBjb25maWcgcHJvcGVydGllc1xuICAgIGxldCBkZWZhdWx0S2V5O1xuICAgIGZvciAoZGVmYXVsdEtleSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHRyYW5zaWVudFByb3BzLmN1cnJlbnRbZGVmYXVsdEtleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHJhbnNpZW50UHJvcHMuY3VycmVudFtkZWZhdWx0S2V5XSA9IGRlZmF1bHRQcm9wc1tkZWZhdWx0S2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbaGFuZGxlcnMsIGF0dGFjaFRvdWNoXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0SGFuZGxlcnMoKHN0YXRlU2V0dGVyKSA9PiAodHJhbnNpZW50U3RhdGUuY3VycmVudCA9IHN0YXRlU2V0dGVyKHRyYW5zaWVudFN0YXRlLmN1cnJlbnQsIHRyYW5zaWVudFByb3BzLmN1cnJlbnQpKSwgeyB0cmFja01vdXNlIH0pLCBbdHJhY2tNb3VzZV0pO1xuICAgIHRyYW5zaWVudFN0YXRlLmN1cnJlbnQgPSB1cGRhdGVUcmFuc2llbnRTdGF0ZSh0cmFuc2llbnRTdGF0ZS5jdXJyZW50LCB0cmFuc2llbnRQcm9wcy5jdXJyZW50LCBwcmV2aW91c1Byb3BzLmN1cnJlbnQsIGF0dGFjaFRvdWNoKTtcbiAgICByZXR1cm4gaGFuZGxlcnM7XG59XG5cbmV4cG9ydCB7IERPV04sIExFRlQsIFJJR0hULCBVUCwgdXNlU3dpcGVhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/react-swipeable/es/index.js\n");

/***/ })

};
;